---
title: Mysql的索引与B-tree
categories:
  - 数据库
date: 2017-12-31 09:13:04
updated: 2017-12-31 09:13:04
tags: 
  - MySQL
---
MySQL查找效率的提高是通过为表建立索引来实现的，InnoDB更是如此，而其索引据说使用的是B-tree，一直不知道这是个什么东西，晚上抽空查看并了解了一下。

# MySQL查询数据的过程
试想，MySQL把数据存储到磁盘上，查询的时候需要读取数据，如果没有建立一个索引的情况下。那么MySQL不得不逐个读取存储在数据文件内的内容，然后与查询进行匹配也得出数据，这是极其没有效率的事情。

在建立了索引的情况下，那么首先通过索引找到数据的位置，然后直接去磁盘上读取指定位置数据即可。
# b-tree
这棵树与我们生活中理解的有点不同的，它只有**Node（节点）**和**叶子（leaf）**。所有的数据存储在叶子上，并且所有的叶子都距离根节点的距离相同。每个**Node**存储了当前**Node**的键，子节点信息，父节点信息；叶子节点存储了数据。
![b-tree](/res/20171231-b-tree-01.jpg)
图中的蓝色方格内的是节点内的键，P[n]是子节点的指针。通过这样的格式，就把数据有序的组织了起来。
试想我们想要读取一个一行，其在ID上建立了索引，此行的索引值为75的情况下，这个过程是怎么样的。

1. MySQL会读取索引根节点，然后与节点内的键进行比较，确定下一个节点在何处。这里 35 < 75，所以将会读取的下一个节点由指针P[3]确定。  
2. 读取子节点后，继续与节点内的键进行比较，确定指向的叶子节点，这里65 < 75 < 87，将会读取P[2]指向的叶子。  
3.  读取叶子后与气其内的键进行比较，得到数据。B-tree在叶子内存储的不是数据，而是数据的位置指针。  
4. MySQL定位到数据文件的对应位置，读取数据。  

通过三次读取磁盘上的文件，就获得了真正的文件，效率大大的提高。
## B-tree的性质
上图中是一个M为3的B树。  一个M阶的树满足下列条件：

1.　定义任意非叶子结点最多只有M个儿子；且M>2；

2.　根结点的儿子数为[2, M]；

3.　除根结点以外的非叶子结点的儿子数为[M/2, M]；

4.　每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

5.　非叶子结点的关键字个数=指向儿子的指针个数-1；

6.　非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

7.　非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

8.　所有叶子结点位于同一层；
# MySQL索引
MySQL使用 B-tree作为索引结构，每次读取磁盘上的一页，大小为16K。每一页，都是以键-指针的形式进行组织。 InnoDB使用 14-bit的指针。 

## 聚簇索引
这个索引在叶子内保存的不是指针位置，而是数据了，更减少了一次磁盘IO。
## 二级索引
二级索引的叶子保存的行的主键，然后通过主键在聚簇索引中进行查询读取数据。如果主键很长的话，二级索引就会需要更多的空间，所以使用一个短的主键是非常有必要的。
# MySQL索引的物理结构（官方文档 14.11.10节）
所有的InnoDB索引都B-tree，索引记录存储在叶子页上。默认索引页大小是16KB。

当新记录被插入到InnoDB聚簇索引的时候，InnoDB会尝试把当前页的1/16保留以便将来的插入或者更新。如果索引记录是按序插入的，那么插入页将会15/16充满。如果是随机的顺序插入的，其可能是在[1/2, 15,16]。如果索引页的充满比例不及1/2，InnoDB会试图压缩索引树来释放这一页。

改变InnoDB索引页大小是不支持的，也无法保证与非16KB索引页大小正常工作。编译和运行时InnoDB可能会出问题。实际上，被称为`Barracuda`新行格式`ROW_FORMART=COMPRESSED`假设索引页大小最大16KB，并且使用14-bit的指针。

g用不同索引页大小的数据文件和日志文件无法在实例之间无法移植。
