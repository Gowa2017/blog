---
title: lua中的基本概念
categories:
  - Lua
date: 2018-01-22 08:56:35
updated: 2018-01-22 08:56:35
tags:
  - Lua
---
lua中的基本概念包括：值和类型，环境变量及全局环境变量，错误处理，元表及元方法，垃圾回收，协程等。以前从来没有看过，现在仔细的深入了解一下。
<!--more-->
文章来源，[lua官方文档第二章](http://www.lua.org/manual/5.3/manual.html#2)

# 值和类型
Lua是一个*动态类型*语言。也就是说值变量没有类型；只有值有。语言中没有类型定义。所有的值携带了自身类型。

Lua中的所有值是*第一类*的值。这是说所有的值都可以被存储在变量内，或者作为参数传递给函数，或者作为函数返回值。

有8种基本的类型：*nil, boolean, number, string, function, thread, table, userdate*。*nil*类型只有一个值，**nil**，这何其他所有的值不同；其常常表示缺少一个可用的值。*boolean*有两个值，**false, true**。**nil, false**都表达否定条件；其他值表示*true*。*number*表示整数和实数（浮点）。*string*代表不可变的字节序列。Lua是8-bit的字符：字符串可以包含任何8-bit的值，包括`\0`。Lua与编码无关，其不对字符的内容做任何假设。

*number*有两种内部表现方式，或者说两种子类型，*整数*与*浮点*。关于在什么时候用哪一种形式，Lua有明确的规则，但是也会在需要的时候自动进行转换（**3.4.3**节）。因此，程序员很多时候可以选择忽略整数和实数间的不同和在两种不同表现形式上进行控制。标准的Lua使用64-bit整数和双精度（double-precision)（64-bit）浮点数，但是你可以自己编译来让Lua使用32-bit整数和单精度（single-precision 32-bit）浮点数，这对于小型设备和嵌入式系统来说是非常有用的。（在文件`luaconf.h`中查看`LUA_32BITS`宏）

Lua可以调用（和操作）用Lua和C写的函数（**3.4.10**节）。这两种形式的函数都是*function*类型。

*userdata*专门用来在Lua变量内存储C数据。一个userdata的值表示一块物理内存。有两种userdata：*full userdata（完全用户数据）*，Lua管理的对象的一块内存，*light userdata（轻量用户数据）*，一个 C的指针值。*userdata*没有预定义的操作，除了赋值和相等测试。通过使用*metatables*，程序员可以对*完全用户数据*值定义操作。用户数据值不能在Lua内创建或者修改，只能通过C API。这样保证了被宿主程序所有用数据的完整性。

*thread*代表了一个独立的执行线程，且被用来实现协程（**2.6**节）。Lua线程和操作系统线程没关系。Lua在所有系统上都支持协程，即使是那些原生不支持线程的系统。

*table*实现了关联数组，也就是说，数组不止可以用数字进行索引，可以用除了**nil**和Nan外的所有Lua值来索引。（NaN，Not a Number，是一个特殊的值，用来代表未定义或不可表示不了的数字结果，比如0/0）表可以是*异构的*，就是说，其可以包含所有类型的值（不包括**Nnil**）。任何键为**nil**的值不被认为是表的一部分。换句话说，任何不存在于表内的键，其关联值为**nil**。

 表是Lua中唯一的数据结构；可以用来表示 普通数组、表、符号表、集合、记录 、图、树等。为了表示记录，Lua使用字段名作为索引。LUa通过提供 `a.name`作为`a["name"]`的语法糖来支持这种表示方式。Lua有几种便利建表的方式。

跟索引一样，表的字段可以是任何类型。实际上，因函数是第一类值，所以表字段可以包含函数。因此，表也可以拥有*methods(方法)*（**3.4.11**节）

表的索引遵循语言中的直接比较定义。如果，同时也只有`i, j`直接相等（这是说不是通过方法来比较）的时候，表达式`a[i], a[j]`表示表中的同一个元素。实际上，含有整型值的浮点数和他们的期待的整型值相等（如， `1.0 == 1`）为了消除歧义，使用浮点数作为键时会将其转换为对应的整数。具体说，如果写入的是`a[2.0] = true`，表中插入的键是整数2。（在另外一方面，2 和"2"是不同的Lua值，因此代表了不同的表中项）

表，函数，线程，和(full)用户数据都是*对象*：变量并不真正包含他们的值，只是*引用*他们。赋值，参数传递，函数返回同样总是操作对这些值的引用；这些操作不会进行任何形式的复制。

库函数`type()`返回给定值的类型描述（**6.1**节）


# 环境变量，全局环境变量

跟我们将在**3.2, 3.3.3**节讨论的那些，对一个自由名字（就是说，一个没有被任何声明所限制范围的名字）`var`的引用语法上被翻译为`_ENV.var`。此外，每个*chunk*都被编译到一个叫`_ENV`的外部本地变量范围内，所以`_ENV`不会是一个*chunk*中的自由名字。

不要管`_ENV`变量的存在和自由名字的翻译，`_ENV`是一个正常的名字。实际上，你可以用那个名字来定义新变量和参数。每个自由名字的引用程序在那个点可见的`_ENV`，遵循Lua常规可见性规则（**3.5**节）

`_ENV`使用来作为值的那张表被称为*环境*。

Lua保持一个叫做*global environment（全局环境）*的特别环境。这个值 保存在C注册表内的一个特殊索引下（**4.5**节）Lua中，全局bmll`_G`被初始化为这个值（`_G`在内部从不使用）。

在Lua再入一个*chunk*时，其`_ENV`上值的默认值是全局环境（参考`load`）。因此，默认情况下，Lua中的自由名字指向全局环境中的一项（因此，也被叫做全局变量）。另外，所有的标准库都被载入到全局环境中，而且某些函数还好在环境上进行操作。可以使用`load()`（或`loadfile()`）来以一个不同的环境再入*chunk*。（在C中，必须先加载*chunk*然后再改变其第一个上值的值来改变环境）。
# 错误处理
因Lua是一个嵌入扩展语言，所有的Lua动作都从宿主程序中调用一个Lua库函数的代码开始。（单独使用Lua的时候，`lua`就是宿主程序）当在编译或执行Lua*chunk*出现错误的时候，控制返回到宿主，由宿主程序采用何时的方式处理（比如打印错误信息）。

Lua代码可以通过`error()`函数来显式产生一个错误。如果要在Lua中捕捉错误，可以用`pcall(), xpcall()`在*protected mode（保护模式）*来调用一个函数。

但有一个错误的时候，*error object（错误对象，也被叫做错误信息）*和包含这个错误信息被抛出。Lua只产生错误对象是一个字符串的错误，但是程序可能会产生任何类型的错误对象。这取决于Lua程序或其宿主程序怎么样来处理这些错误对象。

当使用`xpcall(), lua_pcall()`时，应该提供一个`message handler（消息处理器）`来处理错误。这两个函数以原始的错误对象进行调用，然后返回一个新的错误对象。其在栈被错误展开前调用，所以其能搜集更多关于错误的信息 ，这通过检查栈和建立一个栈回溯来实现。这个消息处理器也被保护模式保护，所以，在消息处理器内产生的错误会再次调用消息处理器。如果这个循环有点久，Lua会中断它并返回一个合适的信息。（消息处理器只会在常规运行时错误调用。在内存分配错误或运行结束时错误不会调用。
# 元表，元方法
Lua的每个值都可以有一个*metatable*。*metable*是一个原始的Lua表，定义了原始值在特定操作下的行为。可以通过设置元表中特定的字段来改变一个值在某些操作下表现的行为。具体点，当一个非数字的值作为加的操作数时，Lua会检查这个值的*metatable*内的字段`__add`。如果找到，就调用这个函数来进行加操作。


在*metatable*内的每个事件的键是`__`加上前缀 ，对应的值被程为`metamethods`。在前面的例子中，键就是`__add`，值就是进行加操作的那个函数。

可以用`getmetatable`函数来查询整个*metatable*。Lua使用原始访问（`rawget`）来查询*metatable*中的*metamethods*。所以，要获得对象*o*中事件*ev*的元方法，Lua像下面这样操作：

```lua
rawget(getmetatable(o) or {}, "__ev")
```
可以用`setmetatable()`函数来替换表的*metatable*。你不能改变Lua代码中有其他类型的*metatable*，它们只能通过C API来改变。

表和完整用户数据有单独的*metatables*（尽管多个表和用户数据可以共享他们的*metatables*）。每个类型的所有值共享一个`metatable`。默认情况下，值没有`metatable`，但字符库为字符类型设置了一个`metatable`。

```lua
	local str = "hello world"
	local mt = getmetatable(str)
	for k, v in pairs(mt) do
		print(k, v)
	end
	
	-- 直接获取__index 字段
	print(rawget(getmetatable(str), "__index"))
```
其输出是:

```
__index	table: 0x7fa075d028a0
table: 0x7fa32fc05170
```
显示了字符串的元表。


一个元表控制一个对象在*数学操作，位移操作，有序比较，连接，长度操作，调用，索引*上的行为。一个元表也可以定义一个用户数据或表被垃圾回收的时候执行的函数。

被元表控制的详细事件列表在下面。每个操作被对应的件所指定：

* **__add**: + 操作。如果任何加法操作的操作数不是数字（或不能由字符串转换为数字），Lua就会尝试调用这个元方法。首先，Lua会检查第一个操作数（即使其是合法的）。如果这个操作数没有为`__add`定义一个元方法，Lua会检查第二个操作数。如果Lua这时找到一个元方法，就会以这两个操作数为参数调用元方法，返回值是就是这个操作的结果。否则，这将会产生一个错误。  
* **__sub**: - 操作。
* **__mul**: * 操作。
* **__div**: / 操作。
* **__mod**: % 操作。
* **__pow**: ^ 操作。
* **__unm**: 负号 。
* **__idiv**: // 操作。
* **__band**: & 位与操作。行为和加操作类似，但当任何一个操作数不是整数或可转换为整的字符串时会调用一个元方法。
* **__bor**: | 位或操作。
* **__bxor**: ~ 异或操作。
* **__bnot**: ~ 位非操作。
* **__shl**: << 左移操作。
* **__shr**: >> 右移操作。
* **__concat**: .. 操作。和加操作行为类似，但当任意一个操作数不是字符也不是数字时会调用元方法。
* **__len**: # 长度操作。如果对象不是字符串，Lua会调用元方法。如果有元方法，Lua以这个对象为参数调用元方法，返回结果就是操作的结果。如果没有应该元方法，但是对象是一个表，Lua就使用表长度操作。否则，Lua会产生错误。
* **__eq**: == 等于操作。
* **__lt**: < 小于操作。
* **__le**: <= 操作
* **_index**: 索引访问table[key]。当*table*不是一个表或*key*不在当前表中时，事件会被触发。这个元方法会在*table*内寻找。

不要管名字，这个事件的元方法可以是函数或一个表。如果是个函数，其以*table, key*作为函数，返回值就是操作的返回值。如果是一个表，最终的结果是以*key*索引这个表的结果。（这个索引流程是常规流程，不是直接索引，因此这次索引也有可能触发另外一个元方法）。

当__index元方法是一个函数时：

```lua
-- 当 __index 是一个函数时
mt = {}
mt.__index = function (table, key) print("in t.mt.__index"); print(table, key); return "mt.__index return" end

local t = { 1, 2, 3, 4}
setmetatable(t, mt)
print(t[8])
```
我们在没有键*8*的时候进行索引访问，其输出如下:

```
in t.mt.__index
table: 0x7fa797604200	8
mt.__index return
```

在这里面，我们设置的`__index`事件函数的返回值是一个字符串*mt.__index return*，结果确实如此。

当`__index`是一个表的时候：

```lua
a = { x = 1, y = 2, z = 3}
b = { 1, 2 ,3}
b.__index = b
setmetatable(a, b)

print(a[1])
```

其输出是: 

	1


说明确实是访问了其元表中`__index`事件中表的对应索引值。确实如上所说。

* **__newindex**: 索引赋值`table[key] = value`。跟`__index`事件类似，这个事件在*table*不是一个表或*key*不在*table*中时发生。元方法在*table*表内寻找。

和索引访问一样，事件的元方法可以是函数和表。如果是函数，以*table, key, value*为参数进行调用元方法。如果是一个表，Lua以同样的键和值对此表进行赋值操作。（这个赋值是常规流程，非直接，因此可能会触发另外一个元方法）。

如果有一个`__newindex`元方法，Lua不会进行一个原始的赋值。（如果必要，元方法自身可以调用`rawset`来进行原始赋值）。

当元方法是一个函数时：

```lua
mt1 = {}
mt1.__newindex = function (table, key, value) print(table, key, value);return "hello" end

t = {}
setmetatable(t, mt1)

t.a = "world"

print(t.a)
```

输出是:

```
table: 0x7fe611c070c0	a	world
nil
```

如果是一个表呢：

```lua
a = {}
mt = {}
mt.__newindex = a

t = {}
setmetatable(t, mt)

t.a = "world"

print(t.a, a.a)
```

输出是：

```
nil		world
```

其结果就是，赋值赋到了`__newindex`元方法的表中。

* **__call**: 调用操作`func(args)`。这在Lua调用一个非函数的值时发生（也就是说，*func*不是一个函数）。元方法在*func*内寻找。如果找到，*func*作为第一个参数调用元方法，后面是原始的参数*args*。调用结果就是操作的结果。（这是唯一一个允许多个结果的元方法）。

在一个表被设置为其他对象的元表前，添加好所有需要的元方法是非常好的一个实践。实际上，`__gc`元方法只在按这个顺序写代码的时候工作。

因为元表是常规表，其也能包含任何字段，而不只是事件名。某些标准库中的函数（如,`tostring`）使用元表中的其他字段来实现特定的目的。

# 垃圾回收
Lua进行自动内存管理。这意味着你不用担心如何给新对象分配内存和在对象不在需要的时候进行释放。Lua通过运行一个*垃圾回收器*自动搜集所有死亡对象（说的是Lua不能继续访问的对象）来自动管理内存。Lua使用的所有内存都服从自动管理：字符串，表，用户数据，函数，线程，内部结构等。

Lua实现一个增量的标记-扫描搜集器。其通过两个数字来控制垃圾回收循环：*garbage-collector pause（垃圾回收暂停）*和*garbage-collector step multiplier（垃圾回收步进倍率）*。这两个字都使用百分比作为单位（例，100在内部表示为值1）。

*垃圾回收暂停*控制在开始一个新的循环前等待的时间。较大的值让搜集器变得不积极。比100小的值意味着搜集器不会等待一个新的循环。200这个值意味着搜集器会等待直到总共使用的内存达到两倍才开始一个新循环。

*垃圾回收步进倍率*控制了搜集器相对与内存分配的速度。较大的值会让搜集器非常的积极，但也会增加每个增量步长的大小。不应该使用小于100的值，因为这让收集器非常的慢，还有可能造成这个收集器永远不会完成一个循环。默认值是200，表示收集器的运行速度是内存分配速度的两倍。

如果把步进倍率设置一个非常大的数字（超过程序可能使用最大字节数的10%），收集器的行为就像一个 *stop-the-world*收集器。然后如果你设置 暂停值 为200，收集器的行为就跟老版本的Lua一样，在Lua使用内存翻倍时，就会进行一次完整的内存收集。

可以通过C中的`lua_gc`函数 或Lua中的`collectgarbage`函数来改变这些值。也可以使用这些函数来直接控制收集器（比如停止与重启）。
## 垃圾回收元名方法
可为表设置垃圾回收元方法，而对完全用户数据需要使用C API。这些元方法也被叫做*finalizers（终止器）*。终止器允许将Lua的垃圾回收和外部的资源管理相结合使用（比如，关闭文件、网络或数据库连接，释放内存等）

对于将要在收集的时候进行终止的对象（表或用户数据），必须 标记其需要终止。当为对象设置一个元表，且元表中有一个字段是以`__gc`进行索引时，这个对象就被标记为需要终止器。注意，如果设置了一个不含有`__gc`的元表，而你随后创建了这个字段，这个对象是不会标记为需要终止的。

当一个标记的对象变成垃圾后，其不会立即被垃圾回收器回收。Lua会把它放在一个链表内。回收结束后，Lua会遍历这个链表。对于表中每个对象，检查对象的`__gc`方法：如果是一个函数，以对象作为参数调用这个函数；如果方法不是一个函数，Lua忽略它。

在每个垃圾回收循环的结束，对象的终止器会以在这个回收循环中对象被标记相反的顺序执行；这就是说，第一个调用的终止器是在程序中最后被标记的对象的`__gc`方法。每个终止器的秩序可能发生在正常代码执行的任何时刻。

因为回收后的对象必须仍然能被终止器使用，那些对象（和那些只能通过它访问到的对象）必须被Lua复活。通常，复活是短暂的，这个对象的内存会在下一个垃圾回收循环中释放。然而，如果终止器将对象存储在全局位置（如全局变量），这个复活就是永久的了。此外，如果终止器标记了某个对象重复被终止，终止器会这个对象不可访问的下一个循环中被调用。无论什么情况，这个对象的内存只会在此对象不可达且没有被标记为需要终止的GC 循环中释放。

当关闭一个状态(state，lua_close）时，Lua会调用所有标记为需要终止对象的终止器，与其被标记的顺序相反。如果在此过程中有终止器标记对象需要回收，这些标记是无效的。


## Weak表

一个`weak table（弱表）`指的是所有元素都是`weak references（弱引用）`的表。弱表会被垃圾回收器忽略。换句话说，一个对象只有一个弱引用，那么垃圾回收器就会回收那个对象。

弱表可以有弱键，弱值，或者两者都有。有弱值的表允许回收它键的值，但是不允许回收键。有弱值和弱键的表允许回收键和值。无论哪种情况，只要键或值中有一个被回收，整个键值对就从表中移除。表的弱属性由其元表中的`__mode`字段控制。如果`__mode`字段的字符串中还有字符`k`，表中的键就是弱的。如果包含`v`，那值就是弱的。

一个有弱键强值的表被叫做暂时表。在一个暂时表中，只有在键是可达的时候值才被认为是可达的。实际上，键的唯一引用是其值进行的话，这个键值对会被移除。

对表弱属性的改变只会在下一个回收循环中产生影响。实际上，如果把弱属性改为强的话，Lua会在变化生效前回收表中的某些项目。

有一个显式构建器的对象会从弱表中移除。值，比如数字和轻量C函数，是不服从垃圾回收的，因此不会从弱表中移除（除非他们相关联的值被回收）。尽管字符串服从垃圾回收，他们没有显式的构建器，因此不会从弱表种移除。

复活后的对象（就是说，终止后的对象和只能通过终止后对象访问的对象）在弱表中有一个特殊的行为。他们会在执行他们的终止器前从弱值中移除，但只会在运行完终止器后的下一个回收中从弱键移除，这个时候这些对象已经被释放了。这个行为允许终止器访问通过此对象通过弱表所关联的属性。

如果一个弱表在这个回收循环的复活对象中，在下个循环前，这个对象可能不会被正确地清理。
# 协程
Lua支持协程，也被叫做*collaborative multithreading*（协作多进程）。一个协程代表了一个独立的执行线程。跟多线程系统中的线程不一样，一个协程只会在显式的执行了一个yield函数后挂起。

通过`coroutine.create()`来创建一个协程。其唯一的参数是这个协程的主函数。`create`函数仅仅只是创建一个新的协程然后返回一个句柄（一个thread类型的对象）给主函数；并不会启动协程。

通过`coroutine.resume()`来执行协程。第一次调用`coroutine.resume()`，传递`coroutine.create()`返回的thread作为第一个参数，这个协程通过调用其主函数进行启动。其他的传递到`coroutine.resume()`的参数被传递给协程主函数。一旦协程开始执行，其会执行到终止或调用*yields*。


一个协程可以通过两种方式来终止执行：通常，其主函数返回（显式或隐式，在最后一条指令后）；和异常返回，如果有一个不受保护的错误。在正常终止时，`coroutine.resume`返回**true**，加上被主函数返回的值。在错误返回时，`coroutine.resume`返回**false**和一个错误对象。

通过`coroutine.yield()`来放弃一个协程。当一个协程放弃，对应的`coroutine.resume()`立刻返回，即使这个放弃发生在嵌套的函数调用中（就是说，不是在主函数中，但在被主函数直接或非直接调用的函数中）。在放弃的情况下，`coroutine.resume()`返回**true**，加上传递给`coroutine.yield()`的值。在下次重启同样协程的时候，其从其放弃的位置开始重启，调用`coroutine.yield()`返回任何额外传递给`coroutine.resume()`的参数。

跟`coroutine.create()`相似，`coroutime.wrap()`函数也会创建一个协程，但其会返回一个函数而不是协程自身，调用这个函数的时候会重启协程。传递到这个函数的参数会作为`coroutine.resume()`的额外参数。`coroutine.wrap()`返回所有被`coroutine.resume()`返回的值，不包括第一个（布尔错误代码）。与`coroutine.resume`不一样的是，`coroutine.wrap`不会捕捉任何错误；任何错误都会抛给调用者。

我们看一下下面的代码来研究一个协程是怎么工作的：

```lua
function foo (a)
	print("foo",a)
	return coroutine.yield(2*a)
end

co = coroutine.create(function (a,b)
		print("co-body", a, b)
		local r = foo(a+1)
		print("co-body", r)
		local r, s = coroutine.yield(a+b, a-b)
		print("co-body", r, s)
		return b, "end"
	end)

	print("main", coroutine.resume(co, 1, 10))
 	print("main", coroutine.resume(co, "r"))
 	print("main", coroutine.resume(co, "x", "y"))
 	print("main", coroutine.resume(co, "x", "y"))
```

当运行的时候，会产生下面的输出：

```lua
	  co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
```

 

同样可以通过C API来创建和操作协程：查看函数`lua_newthread(), lua_resume, lua_yield`。
我们来仔细的看一下这个过程。

1.  首先建立一个协程*co*
2. `coroutine.resume(co, 1, 10)`会以参数`1, 10`启动`co`。首先打印出*co-body, 1, 10*然后调用`foo(1 + 1)`。
3. 在`foo()`中，打印出参数的值这里是2，然后放弃当前协程。放弃协程会返回`coroutine.yield()`返回的值，已经**true**。所以输出是`main true 4`
4. 从调用`foo(a+1)`的位置重启协程，这会继续执行，被调用`coroutine.yield(a+b, a-b)`返回值是`true 11 -9`。
